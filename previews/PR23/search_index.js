var documenterSearchIndex = {"docs":
[{"location":"limitations/#Limitations-and-future-work:","page":"Limitations","title":"Limitations and future work:","text":"","category":"section"},{"location":"limitations/","page":"Limitations","title":"Limitations","text":"There are a couple of things to keep into consideration when using the package:","category":"page"},{"location":"limitations/","page":"Limitations","title":"Limitations","text":"GPU testing is technically supported, but it requires more effort from the developer to set up since the automatic measurements apart from time elapsed do not apply to GPUs (as of now).\nThe automatic flop counting feature works exclusively for Julia native functions, it can not measure the flops in C calls given the limitations of the subjacent package [CountFlops.jl]","category":"page"},{"location":"limitations/#Features-to-be-expected-in-the-next-versions:","page":"Limitations","title":"Features to be expected in the next versions:","text":"","category":"section"},{"location":"limitations/","page":"Limitations","title":"Limitations","text":"Easier access to performance suite results after execution\nSimplification of the package structure, there will be an emphasis on making the package easy to extend for unfamiliarised developers (hopefully by June 2025)\nAccess to performance counter values through LIKWID (hopefully by June 2025)\nAlternative regression testing against git commits instead of last execution for easier testing","category":"page"},{"location":"examples/memcopyCellArray3D/#Basic-example:-time-regression","page":"Basic example: time regression","title":"Basic example: time regression","text":"","category":"section"},{"location":"examples/memcopyCellArray3D/","page":"Basic example: time regression","title":"Basic example: time regression","text":"Given a very simple function, which can be replaced by any other the user might want, we will build a time regression performance test suite.","category":"page"},{"location":"examples/memcopyCellArray3D/","page":"Basic example: time regression","title":"Basic example: time regression","text":"function testfun(a :: Int)\n    c = 1\n\n    for i in 1:a\n        c = c + (i ^ 2) / c\n    end\n\n    return c\nend","category":"page"},{"location":"examples/memcopyCellArray3D/","page":"Basic example: time regression","title":"Basic example: time regression","text":"The source file for the test suite would then be:","category":"page"},{"location":"examples/memcopyCellArray3D/","page":"Basic example: time regression","title":"Basic example: time regression","text":"using PerfTest\n\n@testset \"Test unit\" for i in [10000000,20000000,30000000]\n    x = @perftest testfun(10)\nend","category":"page"},{"location":"examples/memcopyCellArray3D/","page":"Basic example: time regression","title":"Basic example: time regression","text":"This source specifies that the function shall be tested for the 3 different values on the test loop. The methodology used is time regression, this methodology will compare the median time attained with an historical reference and fail if outside the default tolerance interval.","category":"page"},{"location":"examples/roofline/#Roofline-example:-option-pricing","page":"Roofline example: option pricing","title":"Roofline example: option pricing","text":"","category":"section"},{"location":"examples/roofline/","page":"Roofline example: option pricing","title":"Roofline example: option pricing","text":"In this example we setup a roofline model methodology to test the resolution of a binomial tree using a slow implementation.","category":"page"},{"location":"examples/roofline/","page":"Roofline example: option pricing","title":"Roofline example: option pricing","text":"rfd_rt(r,t_per_p) = rfd(t) = exp(-r * t * t_per_p)\nup_st(sigma, t_per_p) = exp(sigma * sqrt(t_per_p))\n\nstruct _Parameters\n    sigma   :: Float64\n    periods :: Int\n    t_per_p :: Float64\n    rfd     :: Function\n    up      :: Float64\n    K       :: Float64\n    S0      :: Float64\n    p       :: Float64\nend\n\nfunction setupProblem(sigma, t, periods_per_t, risk_free_rate, strike, price, p) :: _Parameters\n    return _Parameters(\n        sigma,\n        t * periods_per_t,\n        1 / periods_per_t,\n        rfd_rt(risk_free_rate, 1 / periods_per_t),\n        up_st(sigma, 1 / periods_per_t),\n        strike,\n        price,\n        p\n    )\nend\n\nfunction createBinomialTree(p :: _Parameters)::Tuple{Matrix,Array}\n\n    nodes = (p.periods + 1) * p.periods ÷ 2\n    # A and b\n    Tree = zeros(Float64, nodes, nodes)\n    B = zeros(Float64, nodes)\n\n    # Fill the body of the tree with the discounted expectations\n    for period in 1:(p.periods-1)\n        _nodes = ((period-1)*period÷2+1):((period+1)*(period+0)÷2)\n        for node in _nodes\n            Tree[node, node] = -1\n            Tree[node, node+period] = p.p * p.rfd(p.periods - period)\n            Tree[node, node+period+1] = 1 - p.p * p.rfd(p.periods - period)\n        end\n    end\n\n    # Fill the last level of the tree with the prices at maturity\n    xa = ((p.periods - 1) * p.periods ÷ 2 + 1)\n    xb = ((p.periods + 1) * (p.periods + 0) ÷ 2)\n    down = 1 / p.up\n\n    for node in xa:xb\n        Tree[node, node] = 1\n        B[node] = max((p.S0 * p.up^(xb - node) * down^(node - xa)) - p.K, 0.0)\n    end\n    return Tree, B\nend\n\n\nfunction solveTree(A::Matrix, b::Array, periods::Int)::Array\n\n    nodes = (periods + 1) * periods ÷ 2\n    X = zeros(Float64, nodes)\n    # Last level nodes from a to b\n    xa = ((periods - 1) * periods ÷ 2 + 1)\n    xb = ((periods + 1) * (periods + 0) ÷ 2)\n    for node in xa:xb\n        X[node] = b[node]\n    end\n    # Tree core nodes\n    for period in (periods-1):-1:1\n        _nodes = ((period-1)*period÷2+1):((period+1)*(period+0)÷2)\n        for node in _nodes\n            X[node] = A[node, node+period] * b[node+period] + A[node, node+period+1] * b[node+period+1]\n            b[node] = X[node]\n        end\n    end\n\n    return X\nend\n\noption_price(solution :: Array) = solution[1]\n","category":"page"},{"location":"examples/roofline/","page":"Roofline example: option pricing","title":"Roofline example: option pricing","text":"The following is the recipe file that sets up the performance test suite:","category":"page"},{"location":"examples/roofline/","page":"Roofline example: option pricing","title":"Roofline example: option pricing","text":"using Test\nusing PerfTest\n\ninclude(\"main3.jl\")\n\n# CONFIG\n@perftest_config begin\n    regression.enabled = false\n    roofline.autoflops = true\n    roofline.tolerance.min_percentage = 1.0\nend\n\n\n@testset \"Performance Tests\" begin\n\n    @testset \"Tree construction\" begin\n\n        @testset \"Periods\" for n_periods in [16, 64, 128]\n\n            param = setupProblem(0.04, 1, n_periods, 0.04, 100, 100, 0.5)\n\n            @roofline actual_flops=:autoflop target_ratio=0.05 begin\n                mem = ((:iterator + 1) * :iterator)\n                :autoflop / mem\n            end\n            A, b = createBinomialTree(param)\n\n\n            @perftest solveTree(A, b, param.periods)\n        end\n    end\nend","category":"page"},{"location":"examples/roofline/","page":"Roofline example: option pricing","title":"Roofline example: option pricing","text":"The recipe file specifies the following:","category":"page"},{"location":"examples/roofline/","page":"Roofline example: option pricing","title":"Roofline example: option pricing","text":"The target will be evaluated using a roofline model\nThe basic regression methodology is disabled\nThe tolerance below the threshold will be zero\nThe autoflops feature is enabled\nThe roofline macro additionally receives how to calculate the flop count (actual_lops=:autoflop) and the threshold of the actual performance vs model performance is 5%","category":"page"},{"location":"examples/basic/#Basic-example:-time-regression","page":"Basic example: time regression","title":"Basic example: time regression","text":"","category":"section"},{"location":"examples/basic/","page":"Basic example: time regression","title":"Basic example: time regression","text":"Given a very simple function, which can be replaced by any other the user might want, we will build a time regression performance test suite.","category":"page"},{"location":"examples/basic/","page":"Basic example: time regression","title":"Basic example: time regression","text":"function testfun(a :: Int)\n    c = 1\n\n    for i in 1:a\n        c = c + (i ^ 2) / c\n    end\n\n    return c\nend","category":"page"},{"location":"examples/basic/","page":"Basic example: time regression","title":"Basic example: time regression","text":"The source file for the test suite would then be:","category":"page"},{"location":"examples/basic/","page":"Basic example: time regression","title":"Basic example: time regression","text":"using PerfTest\n\n@testset \"Test unit\" for i in [10000000,20000000,30000000]\n    x = @perftest testfun(10)\nend","category":"page"},{"location":"examples/basic/","page":"Basic example: time regression","title":"Basic example: time regression","text":"This source specifies that the function shall be tested for the 3 different values on the test loop. The methodology used is time regression, this methodology will compare the median time attained with an historical reference and fail if outside the default tolerance interval.","category":"page"},{"location":"examples/mock3-roofline/#Roofline","page":"Roofline","title":"Roofline","text":"","category":"section"},{"location":"examples/mock3-roofline/","page":"Roofline","title":"Roofline","text":"This mock example explains how to setup the effective roofline methodology.","category":"page"},{"location":"examples/mock3-roofline/","page":"Roofline","title":"Roofline","text":"using Test\nusing PerfTest\n\n# Disable regression enable verbosity to see successful tests\n@perftest_config \"\n[regression]\nenabled = false\n[general]\nverbose = true\n\"\n\n\n# TEST TARGET\nfunction polynom(x :: Float64, coeff :: Vector{Float64})\n\n    res = 0.\n\n    for i in length(coeff):-1:1\n        res += coeff[i] * x ^ i\n    end\n\n    return res\nend\n\n@testset \"Example\" begin\n\n    N = 50\n\n    coeff = rand(N)\n    x = 1.0\n\n    # To use a variable in macro formulas, it has to be exported (i.e. N)\n    @export_vars N\n    @roofline actual_flops=:autoflop target_ratio=0.1 begin\n        :autoflop / ((1 + N)*4)\n    end\n\n    # Set the target\n    res = @perftest polynom(x, coeff)\nend","category":"page"},{"location":"examples/mock3-roofline/","page":"Roofline","title":"Roofline","text":"This test results in a success to meet the expectation.","category":"page"},{"location":"api/#API-reference","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"This is the official API reference of PerfTest. Note that it can also be queried interactively from the Julia REPL using the help mode:","category":"page"},{"location":"api/","page":"API reference","title":"API reference","text":"julia> using PerfTest\njulia>?\nhelp?> PerfTest","category":"page"},{"location":"api/#Types","page":"API reference","title":"Types","text":"","category":"section"},{"location":"api/#Index","page":"API reference","title":"Index","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Order = [:type]","category":"page"},{"location":"api/#Documentation","page":"API reference","title":"Documentation","text":"","category":"section"},{"location":"api/#PerfTest.ASTRule","page":"API reference","title":"PerfTest.ASTRule","text":"Used by the AST walker to check for expressions that match condition, if they do then modifier will be applied to the expression.\n\nThis is the basic building block of the code transformer, a set of these rules compounds to all the needed manipulations to create the testing suite.\n\n\n\n\n\n","category":"type"},{"location":"api/#PerfTest.Context","page":"API reference","title":"PerfTest.Context","text":"In order to perform with the test suite generation, the AST walk needs to keep a context register to integrate features that rely on the scope hierarchy.\n\n\n\n\n\n","category":"type"},{"location":"api/#PerfTest.MacroParameter-Tuple{Symbol, Type}","page":"API reference","title":"PerfTest.MacroParameter","text":"MacroParameter(name::Symbol, type::Type;\n              validation_function::Function=(_...) -> true,\n              default_value=nothing,\n              has_default::Bool=false,\n              mandatory::Bool=false)\n\nDefine a parameter that can appear in a macro along with properties to validate values when the macro is parsed.\n\nArguments\n\nname: The parameter name as a symbol\ntype: The expected type of the parameter\nvalidation_function: Optional function (returns Bool) to validate parameter values\ndefault_value: Optional default value for the parameter\nhas_default: Whether this parameter has a default value\nmandatory: Whether this parameter is required\n\n\n\n\n\n","category":"method"},{"location":"api/#PerfTest.Methodology_Result","page":"API reference","title":"PerfTest.Methodology_Result","text":"This struct is used in the test suite to save a methodology result, which in turn is constituted of a group of metric results and their references. Additionally, custom elements that are not subject to test are also saved, e.g. informational metrics, printing functions.\n\n\n\n\n\n","category":"type"},{"location":"api/#PerfTest.Metric_Result","page":"API reference","title":"PerfTest.Metric_Result","text":"This struct is used in the test suite to save a metric measurement, therefore its saves the metric name, its units space and its value.\n\n\n\n\n\n","category":"type"},{"location":"api/#PerfTest.Metric_Test","page":"API reference","title":"PerfTest.Metric_Test","text":"This struct is used in the test suite to save a metric test result and its associated data, it saves the reference used and the toreance intervals in absolute and percentual values, also it shows if the test succeded and some additional variables for data printing\n\n\n\n\n\n","category":"type"},{"location":"api/#PerfTest.Perftest_Datafile_Root","page":"API reference","title":"PerfTest.Perftest_Datafile_Root","text":"This struct is the root of the data recording file, it can save several performance test suite execution results.\n\n\n\n\n\n","category":"type"},{"location":"api/#PerfTest.Suite_Execution_Result","page":"API reference","title":"PerfTest.Suite_Execution_Result","text":"This struct saves a complete test suite result for one execution. It also saves the raw measurements obtained from the targets.\n\n\n\n\n\n","category":"type"},{"location":"api/#PerfTest.Test_Result","page":"API reference","title":"PerfTest.Test_Result","text":"NOTE: SOME METRICS ARE REPEATED IN HERE AND INSIDE A METRIC RESULT, this redundancy is tolerated for now, the copy inside the methodology result might be substituted by a reference in the future.\n\n\n\n\n\n","category":"type"},{"location":"api/#Functions","page":"API reference","title":"Functions","text":"","category":"section"},{"location":"api/#Index-2","page":"API reference","title":"Index","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Order = [:function, :macro]","category":"page"},{"location":"api/#Documentation-2","page":"API reference","title":"Documentation","text":"","category":"section"},{"location":"api/#PerfTest._perftest_config-Tuple{String}","page":"API reference","title":"PerfTest._perftest_config","text":"Used on a generated test suite to import the configuration set during generation\n\n\n\n\n\n","category":"method"},{"location":"api/#PerfTest._treeRun-Tuple{Expr, PerfTest.Context, Vararg{Any}}","page":"API reference","title":"PerfTest._treeRun","text":"This method gets a input julia expression, and a context register and executes a transformation of the input that converts a recipe script (input) into a fully-fledged testing suite (return value).\n\nArguments\n\ninput_expr the recipe/source expression. (internally, a.k.a source code space)\ncontext a register that will store information useful for the transformation over its run over the AST of the input\n\n\n\n\n\n","category":"method"},{"location":"api/#PerfTest.abort_if_invalid-Tuple{Any}","page":"API reference","title":"PerfTest.abort_if_invalid","text":"If validation failed with a false, the transform will abort returning an empty expression.\n\n\n\n\n\n","category":"method"},{"location":"api/#PerfTest.addLog","page":"API reference","title":"PerfTest.addLog","text":"Creates and/or appends to a log channel, the message is saved in that channel   depending on verbosity the message will be also sent to standard output.\n\n\n\n\n\n","category":"function"},{"location":"api/#PerfTest.auxiliarMetricPrint-Tuple{PerfTest.Metric_Result, Int64}","page":"API reference","title":"PerfTest.auxiliarMetricPrint","text":"This function is used to dump metric information regading auxiliar metrics, which are not used in testing.\n\n\n\n\n\n","category":"method"},{"location":"api/#PerfTest.buildMemTRPTMethodology-Tuple{PerfTest.Context}","page":"API reference","title":"PerfTest.buildMemTRPTMethodology","text":"Returns an expression used to evaluate the effective memory throughput over a test target\n\n\n\n\n\n","category":"method"},{"location":"api/#PerfTest.buildRegression-Tuple{PerfTest.Context}","page":"API reference","title":"PerfTest.buildRegression","text":"Returns an expression used to evaluate regression over a test target\n\n\n\n\n\n","category":"method"},{"location":"api/#PerfTest.buildRoofline-Tuple{PerfTest.Context}","page":"API reference","title":"PerfTest.buildRoofline","text":"Returns an expression used to generate and evaluate a roofline model over a test target\n\n\n\n\n\n","category":"method"},{"location":"api/#PerfTest.by_index-Tuple{Union{BenchmarkTools.BenchmarkGroup, Dict}, Vector{PerfTest.DepthRecord}}","page":"API reference","title":"PerfTest.by_index","text":"This method expects a hierarchy tree (dict) in the form of nested dictionaries and a vector of dictionary keys idx. The function will recursively index by the keys to get to a final element.\n\nThe DepthRecord struct represents an index.\n\n\n\n\n\n","category":"method"},{"location":"api/#PerfTest.checkType-Tuple{Type}","page":"API reference","title":"PerfTest.checkType","text":"Returns a function that will return if its argument (x) is of type \"type\"\n\n\n\n\n\n","category":"method"},{"location":"api/#PerfTest.clearLogs","page":"API reference","title":"PerfTest.clearLogs","text":"Clears the IOBuffer of the specified channel   if 0 all channels will be cleared.\n\nUnbinds the channels to stdout as well.\n\n\n\n\n\n","category":"function"},{"location":"api/#PerfTest.dumpLogs","page":"API reference","title":"PerfTest.dumpLogs","text":"Prints the selected channel number on stdout\n\n\n\n\n\n","category":"function"},{"location":"api/#PerfTest.dumpLogsString","page":"API reference","title":"PerfTest.dumpLogsString","text":"Prints the selected channel number on a string\n\n\n\n\n\n","category":"function"},{"location":"api/#PerfTest.empty_expr","page":"API reference","title":"PerfTest.empty_expr","text":"Returns an empty expresion for any input\n\n\n\n\n\n","category":"function"},{"location":"api/#PerfTest.extractMethodologyResultArray-Tuple{Dict, Symbol}","page":"API reference","title":"PerfTest.extractMethodologyResultArray","text":"This method will return a flattened array of all of the results for all the methodologies exercised in the provided dictionary.\n\nExample:\n\n\"Test Set 1\"      -> \"Test 1\"          -> Methodology A result          -> Methodology B result  \"Test Set 2\"      -> \"Test 1\"          -> Methodology A result Returns:  M. A result (Test Set 1)  M. B result (Test Set 1)  M. A result (Test Set 2)\n\n\n\n\n\n","category":"method"},{"location":"api/#PerfTest.extractNamesResultArray-Tuple{Dict, Symbol}","page":"API reference","title":"PerfTest.extractNamesResultArray","text":"This method will return a flattened array of the whole test result hierarchy.\n\nExample\n\nExample:\n\n\"Test Set 1\"      -> \"Test 1\"          -> Methodology A result          -> Methodology B result  \"Test Set 2\"      -> \"Test 1\"          -> Methodology A result Returns:  \"Test Set 1 -> Test 1 -> Methodology A\"  \"Test Set 1 -> Test 1 -> Methodology B\"  \"Test Set 2 -> Test 1 -> Methodology A\"\n\n\n\n\n\n","category":"method"},{"location":"api/#PerfTest.flattenedInterpolation-Tuple{Expr, Expr, Symbol}","page":"API reference","title":"PerfTest.flattenedInterpolation","text":"This method interpolates the inside_expr into outside_expr anywhere it finds the token substitution_token, which is a symbol. The outside_expr has to be a block or a quote block. It has the particularity that it will remove block heads from the inside_expr and add the nested elements onto the location where the token it.\n\nExample:\n\noutside_expr = :(:A; 4)\n\ninside_expr = :(begin 2;3 end)\n\nsubstitution_token = :A\n\nreturns = :(2;3;4)\n\n\n\n\n\n","category":"method"},{"location":"api/#PerfTest.genTestName!-Tuple{PerfTest.Context}","page":"API reference","title":"PerfTest.genTestName!","text":"Function that generates a test name if needed, it is used to name   test targets to distinguish them if several go in the same testset.\n\n\n\n\n\n","category":"method"},{"location":"api/#PerfTest.getMetricValue-Tuple{Vector{PerfTest.Methodology_Result}, String}","page":"API reference","title":"PerfTest.getMetricValue","text":"Given a series of methodology results, the the raw values of all the metrics contained in the methodology results.\n\n\n\n\n\n","category":"method"},{"location":"api/#PerfTest.getNumber-Tuple{String}","page":"API reference","title":"PerfTest.getNumber","text":"From a string (field), it will parse the first number it finds as a Float\n\n\n\n\n\n","category":"method"},{"location":"api/#PerfTest.get_failed_tests-Tuple{PerfTest.Perftest_Datafile_Root}","page":"API reference","title":"PerfTest.get_failed_tests","text":"This function will return all tests that failed (i.e., where succeeded is false).\n\n\n\n\n\n","category":"method"},{"location":"api/#PerfTest.get_metric_results-Tuple{PerfTest.Perftest_Datafile_Root, AbstractString}","page":"API reference","title":"PerfTest.get_metric_results","text":"This function will return all results for a specific metric across all methodologies.\n\n\n\n\n\n","category":"method"},{"location":"api/#PerfTest.get_metrics_for_test-Tuple{PerfTest.Perftest_Datafile_Root, AbstractString}","page":"API reference","title":"PerfTest.get_metrics_for_test","text":"This function will return all metrics for a specific test name.\n\n\n\n\n\n","category":"method"},{"location":"api/#PerfTest.grepOutput-Tuple{String, Union{Regex, String}}","page":"API reference","title":"PerfTest.grepOutput","text":"From a string, it will divide it by lines and retrieve the ones that match the regular expression provided.\n\n\n\n\n\n","category":"method"},{"location":"api/#PerfTest.grepOutputXGetNumber-Tuple{String, String}","page":"API reference","title":"PerfTest.grepOutputXGetNumber","text":"Given a string output, it will retrieve the first number in the first line that contains the string string.\n\n\n\n\n\n","category":"method"},{"location":"api/#PerfTest.loadFileAsExpr-Tuple{AbstractString}","page":"API reference","title":"PerfTest.loadFileAsExpr","text":"Utility to get an expression from a Julia file stored at path\n\n\n\n\n\n","category":"method"},{"location":"api/#PerfTest.match_failure-Tuple{Any}","page":"API reference","title":"PerfTest.match_failure","text":"Constructs an ASTRule that will always match. The onfail function will then be applied.   Useful to catch a match failure.\n\nArguments:\n\nonfail : a function that receives a Context argument.\n\n\n\n\n\n","category":"method"},{"location":"api/#PerfTest.metaGet-Tuple{AbstractVector, Symbol}","page":"API reference","title":"PerfTest.metaGet","text":"Runs over an array of expressions trying to match the desired one.   If not found returns \"Nothing\".\n\n\"sym\" should follow the MacroTools nomenclature for the @capture macro\n\n\n\n\n\n","category":"method"},{"location":"api/#PerfTest.metaGetString-Tuple{AbstractVector}","page":"API reference","title":"PerfTest.metaGetString","text":"\n\n\n\n","category":"method"},{"location":"api/#PerfTest.newLocalScope-Tuple{String, Expr}","page":"API reference","title":"PerfTest.newLocalScope","text":"Creates a new level in the dictionary and updates the local context with the new level\n\n\n\n\n\n","category":"method"},{"location":"api/#PerfTest.newLocalScopeFor-Tuple{String, Union{Expr, LineNumberNode, QuoteNode, Symbol}, Expr}","page":"API reference","title":"PerfTest.newLocalScopeFor","text":"Creates a new level in the dictionary and updates the local context with the new level\n\nApplies to hierarchy levels with an iteration series.\n\n\n\n\n\n","category":"method"},{"location":"api/#PerfTest.no_transform","page":"API reference","title":"PerfTest.no_transform","text":"Keeps the expression as it it\n\n\n\n\n\n","category":"function"},{"location":"api/#PerfTest.onMemoryThroughputDefinition-Tuple{Union{Expr, LineNumberNode, QuoteNode, Symbol}, PerfTest.Context, Any}","page":"API reference","title":"PerfTest.onMemoryThroughputDefinition","text":"Called when a effective memory throughput macro is detected, sets up the effective memory throughput methodology\n\n\n\n\n\n","category":"method"},{"location":"api/#PerfTest.onRegressionDefinition-Tuple{Union{Expr, LineNumberNode, QuoteNode, Symbol}, PerfTest.Context, Any}","page":"API reference","title":"PerfTest.onRegressionDefinition","text":"Called when a regression macro is detected, sets up the regression methodology\n\n\n\n\n\n","category":"method"},{"location":"api/#PerfTest.onRooflineDefinition-Tuple{Union{Expr, LineNumberNode, QuoteNode, Symbol}, PerfTest.Context, Any}","page":"API reference","title":"PerfTest.onRooflineDefinition","text":"Called when a roofline macro is detected, sets up the roofline methodology\n\n\n\n\n\n","category":"method"},{"location":"api/#PerfTest.openDataFile-Tuple{AbstractString}","page":"API reference","title":"PerfTest.openDataFile","text":"This method is used to get historical data of a performance test suite from a save file located in path.\n\n\n\n\n\n","category":"method"},{"location":"api/#PerfTest.p_blue-Tuple{Any}","page":"API reference","title":"PerfTest.p_blue","text":"Prints the element in color blue\n\n\n\n\n\n","category":"method"},{"location":"api/#PerfTest.p_green-Tuple{Any}","page":"API reference","title":"PerfTest.p_green","text":"Prints the element in color green\n\n\n\n\n\n","category":"method"},{"location":"api/#PerfTest.p_red-Tuple{Any}","page":"API reference","title":"PerfTest.p_red","text":"Prints the element in color red\n\n\n\n\n\n","category":"method"},{"location":"api/#PerfTest.p_yellow-Tuple{Any}","page":"API reference","title":"PerfTest.p_yellow","text":"Prints the element in color yellow\n\n\n\n\n\n","category":"method"},{"location":"api/#PerfTest.popQuoteBlocks-Tuple{Expr}","page":"API reference","title":"PerfTest.popQuoteBlocks","text":"Useful to correct operations limited by the tree walking  Will remove quote blocks inside the main block without recursion and push  their expressions into the main block\n\n\n\n\n\n","category":"method"},{"location":"api/#PerfTest.printDepth!-Tuple{AbstractArray}","page":"API reference","title":"PerfTest.printDepth!","text":"This method is used to print the test names, with consideration on the hierarchy and adding indentation whenever necessary\n\n\n\n\n\n","category":"method"},{"location":"api/#PerfTest.printIntervalLanding","page":"API reference","title":"PerfTest.printIntervalLanding","text":"This method is used to print a graphical representation on a test result and the admisible intervals it can take. The result will and the two bounds will be printed in order.\n\n\n\n\n\n","category":"function"},{"location":"api/#PerfTest.printMethodology-Tuple{PerfTest.Methodology_Result, Int64, Bool}","page":"API reference","title":"PerfTest.printMethodology","text":"This function is used to print the information relative to a methodology, relative to a a specific test execution result. This will usually print a series of metrics and might also print plots.\n\n\n\n\n\n","category":"method"},{"location":"api/#PerfTest.printMetric-Tuple{PerfTest.Metric_Result, PerfTest.Metric_Test, Int64}","page":"API reference","title":"PerfTest.printMetric","text":"This method is used to dump into the output the information about a metric and the value obtained in a specific test.\n\n\n\n\n\n","category":"method"},{"location":"api/#PerfTest.printfail-Tuple{BenchmarkTools.TrialJudgement, BenchmarkTools.Trial, BenchmarkTools.Trial, PerfTest.FloatRange, Int64}","page":"API reference","title":"PerfTest.printfail","text":"This method dumps into the output a test result in case of failure. The output will be formatted to make it easy to read.\n\n\n\n\n\n","category":"method"},{"location":"api/#PerfTest.regression-Tuple{Symbol, Symbol}","page":"API reference","title":"PerfTest.regression","text":"Syntax sugar\n\nReturns an expression that returns the percentage difference of the new value vs the old value\n\nIf there is no old value 0 will be returned\n\n\n\n\n\n","category":"method"},{"location":"api/#PerfTest.removeBlock-Tuple{Expr}","page":"API reference","title":"PerfTest.removeBlock","text":"Pops expr which has a head that is :block or :quote and returns array of nested expressions which are the arguments of such head.\n\n\n\n\n\n","category":"method"},{"location":"api/#PerfTest.ruleSet-Tuple{PerfTest.Context, Vector{PerfTest.ASTRule}}","page":"API reference","title":"PerfTest.ruleSet","text":"This method builds what is known as a rule set. Which is a function that will evaluate if an expression triggers a rule in a set and if that is the case apply the rule modifier. See the ASTRule documentation for more information.\n\nWARNING: the rule set will apply the FIRST rule that matches with the expression, therefore other matches will be ignored\n\nArguments\n\ncontext the context structure of the tree run, it will be ocassinally used by some rules on the set.\nrules the collection of rules that will belong to the resulting set.\n\n\n\n\n\n","category":"method"},{"location":"api/#PerfTest.saveDataFile-Tuple{AbstractString, PerfTest.Perftest_Datafile_Root}","page":"API reference","title":"PerfTest.saveDataFile","text":"This method is used to save historical data of a performance test suite to a save file located in path.\n\n\n\n\n\n","category":"method"},{"location":"api/#PerfTest.saveExprAsFile","page":"API reference","title":"PerfTest.saveExprAsFile","text":"Utility to save an expression (expr) to a Julia file stored at path\n\nRequires a :toplevel symbol to be the head of the expression.\n\n\n\n\n\n","category":"function"},{"location":"api/#PerfTest.saveLogFolder-Tuple{}","page":"API reference","title":"PerfTest.saveLogFolder","text":"Moves the temporal log directory to the persistent directory where results are saved   and dumps all IOStream buffers to their respective log files\n\n\n\n\n\n","category":"method"},{"location":"api/#PerfTest.saveMethodologyData-Tuple{AbstractString, PerfTest.Methodology_Result}","page":"API reference","title":"PerfTest.saveMethodologyData","text":"TODO\n\n\n\n\n\n","category":"method"},{"location":"api/#PerfTest.setLogFolder-Tuple{}","page":"API reference","title":"PerfTest.setLogFolder","text":"Creates temporal a directory for the logs of a specific execution\n\n\n\n\n\n","category":"method"},{"location":"api/#PerfTest.testsetUpdate!-Tuple{PerfTest.Context, String}","page":"API reference","title":"PerfTest.testsetUpdate!","text":"Function used to register a new test set in the hierarchy record of the context, where name is the name of the test set.\n\n\n\n\n\n","category":"method"},{"location":"api/#PerfTest.toggleMPI-Tuple{}","page":"API reference","title":"PerfTest.toggleMPI","text":"In order for the suite to be MPI aware, this function has to be called. Calling it again will disable this feature.\n\n\n\n\n\n","category":"method"},{"location":"api/#PerfTest.treeRun-Tuple{AbstractString}","page":"API reference","title":"PerfTest.treeRun","text":"This method implements the transformation that converts a recipe script into a fully-fledged testing suite. The function will return a Julia expression with the resulting performance testing suite. This can be then executed or saved in a file for later usage.\n\nArguments\n\npath the path of the script to be transformed.\n\n\n\n\n\n","category":"method"},{"location":"api/#PerfTest.unblockAndConcat-Tuple{Vector{Expr}}","page":"API reference","title":"PerfTest.unblockAndConcat","text":"This function is useful to move expressions to the toplevel when they are enclosed inside a block\n\n\n\n\n\n","category":"method"},{"location":"api/#PerfTest.validASTRule-Tuple{Any, Any}","page":"API reference","title":"PerfTest.validASTRule","text":"Constructs an ASTRule that assumes that the expression is automatically valid if matched.   Thus no validation is done.\n\n\n\n\n\n","category":"method"},{"location":"api/#PerfTest.verboseOutput-Tuple{AbstractString}","page":"API reference","title":"PerfTest.verboseOutput","text":"Binds a channel to the standard output\n\n\n\n\n\n","category":"method"},{"location":"api/#Test.print_test_results-Tuple{PerfTest.PerfTestSet}","page":"API reference","title":"Test.print_test_results","text":"Will print the overall result of the test suite execution \n\n\n\n\n\n","category":"method"},{"location":"api/#PerfTest.@auxiliary_metric-Tuple{Any, Any, Any}","page":"API reference","title":"PerfTest.@auxiliary_metric","text":"Defines a custom metric for informational purposes that will not be used for testing but will be printed as output.\n\nArguments\n\nname : the name of the metric for identification purposes.\nunits : the unit space that the metric values will be in.\nformula block : an expression that returns a single value, which would be the metric value. The formula can have any julia expression inside and additionally some special symbols are supported. The formula may be evaluated several times, so its applied to every target in every test set or just once, if the formula is defined inside a test set, which makes it only applicable to it.\n\nSpecial symbols:\n\n:median_time : will be substituted by the median time the target took to execute in the benchmark.\n:minimum_time: will be substituted by the minimum time the target took to execute in the benchmark.\n:ret_value : will be substituted by the return value of the target.\n:autoflop: will be substituted by the FLOP count the target.\n:printed_output : will be substituted by the standard output stream of the target.\n:iterator : will be substituted by the current iterator value in a loop test set.\n\n\n\n\n\n","category":"macro"},{"location":"api/#PerfTest.@define_benchmark-Tuple","page":"API reference","title":"PerfTest.@define_benchmark","text":"\n\n\n\n","category":"macro"},{"location":"api/#PerfTest.@define_eff_memory_throughput-Tuple","page":"API reference","title":"PerfTest.@define_eff_memory_throughput","text":"This macro is used to define the memory bandwidth of a target in order to execute the effective memory thorughput methodology.\n\nArguments\n\nformula block : an expression that returns a single value, which would be the metric value. The formula can have any julia expression inside and additionally some special symbols are supported. The formula may be evaluated several times, so its applied to every target in every test set or just once, if the formula is defined inside a test set, which makes it only applicable to it.\nratio : the allowed minimum percentage over the maximum attainable that is allowed to pass the test\n\nSpecial symbols:\n\n:median_time : will be substituted by the median time the target took to execute in the benchmark.\n:minimum_time: will be substituted by the minimum time the target took to execute in the benchmark.\n:ret_value : will be substituted by the return value of the target.\n:autoflop: will be substituted by the FLOP count the target.\n:printed_output : will be substituted by the standard output stream of the target.\n:iterator : will be substituted by the current iterator value in a loop test set.\n\nExample:\n\nThe following definition assumes that each execution of the target expression involves transacting 1000 bytes. Therefore the bandwith is 1000 / execution time.\n\n@define_eff_memory_throughput begin\n      1000 / :median_time\nend\n\n\n\n\n\n","category":"macro"},{"location":"api/#PerfTest.@define_metric-Tuple","page":"API reference","title":"PerfTest.@define_metric","text":"This macro is used to define a new custom metric.\n\nArguments\n\nname : the name of the metric for identification purposes.\nunits : the unit space that the metric values will be in.\nformula block : an expression that returns a single value, which would be the metric value. The formula can have any julia expression inside and additionally some special symbols are supported. The formula may be evaluated several times, so its applied to every target in every test set or just once, if the formula is defined inside a test set, which makes it only applicable to it. NOTE: If there is the need of referring to a variable on a formula block, it first needs to be exported using the macro @export_vars, otherwise an error will occur.\n\nSpecial symbols:\n\n:median_time : will be substituted by the median time the target took to execute in the benchmark.\n:minimum_time: will be substituted by the minimum time the target took to execute in the benchmark.\n:ret_value : will be substituted by the return value of the target.\n:autoflop: will be substituted by the FLOP count the target.\n:printed_output : will be substituted by the standard output stream of the target.\n:iterator : will be substituted by the current iterator value in a loop test set.\n\n\n\n\n\n","category":"macro"},{"location":"api/#PerfTest.@export_vars-Tuple","page":"API reference","title":"PerfTest.@export_vars","text":"@export_vars vars...\n\nExports the specified symbols –along with the values they hold at the moment of the calling– to the scope of metric definitions. In order to use any variable on the definition of a metric such variable needs to be exported with this macro.\n\n\n\n\n\n","category":"macro"},{"location":"api/#PerfTest.@lpad-Tuple{Any}","page":"API reference","title":"PerfTest.@lpad","text":"Macro that adds a space at the beggining of a string\n\n\n\n\n\n","category":"macro"},{"location":"api/#PerfTest.@on_perftest_exec-Tuple{Any}","page":"API reference","title":"PerfTest.@on_perftest_exec","text":"The expression given to this macro will only be executed in the generated suite, and will be deleted if the source code is executed as is.\n\n\n\n\n\n","category":"macro"},{"location":"api/#PerfTest.@on_perftest_ignore-Tuple{Any}","page":"API reference","title":"PerfTest.@on_perftest_ignore","text":"The expression given to this macro will only be executed in the source code, and will be deleted in the generated performance test suite.\n\n\n\n\n\n","category":"macro"},{"location":"api/#PerfTest.@perfcmp-Tuple","page":"API reference","title":"PerfTest.@perfcmp","text":"Same as perfcompare\n\n\n\n\n\n","category":"macro"},{"location":"api/#PerfTest.@perfcompare-Tuple","page":"API reference","title":"PerfTest.@perfcompare","text":"\n\n\n\n","category":"macro"},{"location":"api/#PerfTest.@perftest-Tuple{Any}","page":"API reference","title":"PerfTest.@perftest","text":"This macro is used to signal that the wrapped expression is a performance test target, and therefore its performance will be sampled and then evaluated following the current suite configuration.\n\nIf the macro is evaluated it does not modify the target at all. The effects of the macro only show when the script is transformed into a performance testing suite.\n\nThis macro is sensitive to context since other adjacent macros can change how the target will be evaluated.\n\nUse the parameter \"samples\" to specify the amount of samples (executions) to take.\n\nArguments\n\nThe target expression\nNumber of samples (default: 10000)\n\nExample\n\n@perftest 2 + 3\n@perftest samples=100 2 + 3\n\n\n\n\n\n","category":"macro"},{"location":"api/#PerfTest.@perftest_config-Tuple{Any}","page":"API reference","title":"PerfTest.@perftest_config","text":"Captures a set of configuration parameters that will override the default configuration. The parameters shall be written in TOML syntax, like a subset of the complete configuration (see config.toml generated by executing transform, or transform/configuration.jl for more information). Order is irrelevant. This macro shall be put as high as possible in the test file (code that is above will be transformed using the default configuration).\n\nRecursive transformation:\n\nThis macro will set the new configuration keys for the current file and any other included files. If the included files have the macro as well, those macros will override the configuration locally for each file.\n\nArguments\n\nA String, with the TOML declaration of configuration keys\n\nExample\n\n@perftestconfig \" [roofline]   enabled = false [general]   maxsaved_results = 1   recursive = false \"\n\n\n\n\n\n","category":"macro"},{"location":"api/#PerfTest.@roofline","page":"API reference","title":"PerfTest.@roofline","text":"This macro enables roofline modelling, if put just before a target declaration (@perftest) it will proceed to evaluate it using a roofline model.\n\nMandatory arguments\n\nformula block: the macro has to wrap a block that holds a formula to obtain the operational intensity of target algorithms.\n\nOptional arguments\n\ncpu_peak : a manual input value for the maximum attainable FLOPS, this will override the empirical runtime benchmark\nmembw_peak : a manual input value for the maximum memory bandwith, this will override the empirical runtime benchmark\ntarget_opint : a desired operational intensity for the target, this will turn operational intensity into a test metric\nactual_flops: another formula that defines the actual performance of the test.\ntarget_ratio : the acceptable ratio between the actual performance and the projected performance from the roofline, this will turn actual performance into a test metric.\n\nSpecial symbols:\n\n:median_time : will be substituted by the median time the target took to execute in the benchmark.\n:minimum_time: will be substituted by the minimum time the target took to execute in the benchmark.\n:ret_value : will be substituted by the return value of the target.\n:autoflop: will be substituted by the FLOP count the target.\n:printed_output : will be substituted by the standard output stream of the target.\n:iterator : will be substituted by the current iterator value in a loop test set.\n\nAny formula block specified in this macro supports these symbols.\n\nExample\n\n@roofline actual_flops=:autoflop target_ratio=0.05 begin\n    mem = ((:iterator + 1) * :iterator)\n    :autoflop / mem\nend\n\nThe code block defines operational intensity, whilst the other arguments define how to measure and compare the actual performance with the roofline performance. If the actual to projected performance ratio goes below the target, the test fails.\n\n\n\n\n\n","category":"macro"},{"location":"api/#PerfTest.Configuration.load_config-Tuple{}","page":"API reference","title":"PerfTest.Configuration.load_config","text":"Load configuration from a TOML file.\n\nArgs:\n\nfilepath: Path to the TOML file\nschema: Optional schema for validation\n\nReturns:\n\nLoaded configuration dictionary or nothing\n\n\n\n\n\n","category":"method"},{"location":"api/#PerfTest.Configuration.merge_configs-Tuple{Dict, Dict}","page":"API reference","title":"PerfTest.Configuration.merge_configs","text":"Recursively merge two dictionaries, with values from override_dict taking precedence.\n\n\n\n\n\n","category":"method"},{"location":"api/#PerfTest.Configuration.save_config-Tuple{Dict}","page":"API reference","title":"PerfTest.Configuration.save_config","text":"Save configuration to a TOML file.\n\nArgs:\n\nconfig: Configuration dictionary\nfilepath: Path to save the TOML file\nschema: Optional schema for validation\n\nReturns:\n\nBoolean indicating successful save\n\n\n\n\n\n","category":"method"},{"location":"api/#PerfTest.Configuration.validate_config-Tuple{Dict, Dict}","page":"API reference","title":"PerfTest.Configuration.validate_config","text":"Validate configuration against a predefined schema.\n\nArgs:\n\nconfig: Dictionary to validate\nschema: Dictionary defining expected structure and types\n\nReturns:\n\nBoolean indicating whether configuration is valid\n\n\n\n\n\n","category":"method"},{"location":"api/#PerfTest.BencherInterface.convertValueWithMagnitude-Union{Tuple{T}, Tuple{T, Number}} where T","page":"API reference","title":"PerfTest.BencherInterface.convertValueWithMagnitude","text":"convert_value_with_magnitude(value::T, magnitude_mult::Number) where T\n\nApply magnitude multiplier to the value.\n\n\n\n\n\n","category":"method"},{"location":"api/#PerfTest.BencherInterface.exportToJSON","page":"API reference","title":"PerfTest.BencherInterface.exportToJSON","text":"export_suite_to_json(suite::Suite_Execution_Result) -> Dict\n\nConvert an entire suite execution result to JSON format.\n\n\n\n\n\n","category":"function"},{"location":"api/#PerfTest.BencherInterface.processMethodology-Tuple{PerfTest.Methodology_Result}","page":"API reference","title":"PerfTest.BencherInterface.processMethodology","text":"Process a methodology result to extract and format metrics with their corresponding thresholds.\n\nArgs:     methodology: A Methodology_Result object containing metrics and test information.\n\nReturns:     A dictionary where keys are metric names and values are dictionaries containing the metric's     processed value, lower threshold, and optionally a higher threshold.\n\n\n\n\n\n","category":"method"},{"location":"api/#PerfTest.BencherInterface.processTestHierarchy-Tuple{Dict{String, Union{PerfTest.Test_Result, Dict}}}","page":"API reference","title":"PerfTest.BencherInterface.processTestHierarchy","text":"flatten_test_hierarchy(results::Dict{String, Union{Dict, Test_Result}}, prefix::String=\"\") -> Dict{String, Test_Result}\n\nRecursively flatten a nested dictionary of test results into a single-level dictionary. The hierarchy levels are incorporated into the keys using \"::\" as a separator.\n\nExample:     {         \"level1\": {             \"level2\": {                 \"benchmarkname\": TestResult             }         }     }\n\nbecomes:\n\n{\n    \"level1::level2::benchmark_name\": Test_Result\n}\n\n\n\n\n\n","category":"method"},{"location":"api/#PerfTest.BencherInterface.writeJSONtoFile-Tuple{String, Dict}","page":"API reference","title":"PerfTest.BencherInterface.writeJSONtoFile","text":"write_results_to_file(filepath::String, json_data::Dict)\n\nWrite JSON data to a file.\n\n\n\n\n\n","category":"method"},{"location":"examples/mock4-recursive/#Recursive-Suite-Generation","page":"Recursive Suite Generation","title":"Recursive Suite Generation","text":"","category":"section"},{"location":"examples/mock4-recursive/","page":"Recursive Suite Generation","title":"Recursive Suite Generation","text":"This mock example explains how PerfTest can recursively integrate files into a performance test suite.","category":"page"},{"location":"examples/mock4-recursive/","page":"Recursive Suite Generation","title":"Recursive Suite Generation","text":"using Test\nusing PerfTest\n\n\n# Note the config here disables verbosity but the nested files enable it, inside the nested file its config has priority\n@perftest_config \"\n[regression]\nenabled = false\n[general]\nverbose = false\n\"\n\n@testset \"A\" begin\n    @testset \"A.1\" begin\n        # Check that time elapsed is less than one second, applies to the targets inside this testset\n        @perfcompare :median_time < 1\n        # Being \"mock3-roofline.jl\" a file with the roofline mock example source code.\n        include(\"mock3-roofline.jl\")\n    end\n    include(\"mock3-roofline.jl\")\nend","category":"page"},{"location":"examples/mock4-recursive/","page":"Recursive Suite Generation","title":"Recursive Suite Generation","text":"This will execute the same roofline test but under different hierarchies, also the first one will have an additional performance metric assertion with perfcompare. All test are successful.","category":"page"},{"location":"usage/#Usage","page":"Usage","title":"Usage","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"PerfTest provides a set of macros to instrument ordinary Julia test files with performance tests. The idea is to have the posibility of having a functional and a performance suite all in the same place.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"The underlying idea of declaring performance tests can be boiled down the following:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Have a @testset that groups tests for a software unit\nTell PerfTest what is the target to be tested by using the macro @perftest\nTell PerfTest how the target shall be tested, which metrics are interesting, which of those metrics values would be considered a failure, this can be declared using the metric and methodology macros (see Macros)","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"The following dummy example embodies the paradigm of the package:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"using ExampleModule : innerProduct, Test, PerfTest   # Importing the target and test libraries\n@testset \"Roofline Test\" begin\n    a,b = rand(1e6),rand(1e6)\n\n    @roofline actual_flops=:autoflop target_ratio=0.5\n        :autoflop / (2 * 8 * 1e6)\n    end\n\n    @perftest innerProduct(a, b)\n    @test innerProduct(a,b) == sum(a .* b)\nend","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"The following things can be appreciated in this example:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"This is a combined functional and performance unit test suite (there is both @test and @perftest present)\nThe target of the perftest is the innerProduct function\nThe performance test methodology is a roofline model, the developer expects innerProduct to perform at least at 50% of the maximum flop performance set by the roofline. The operational intensity is defined on the main block of the macro. :autoflop is a symbol that enables the use of an automatic flop count feature.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"For more information have a look at the Examples and see the API reference for details on the usage of PerfTest.","category":"page"},{"location":"usage/#Installation","page":"Usage","title":"Installation","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"PerfTest can be installed directly with the Julia package manager from the Julia REPL:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"julia>]\n  pkg> add https://github.com/JuliaPerf/PerfTest.jl.git","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"<!– PerfTest can be installed directly with the Julia package manager from the Julia REPL: –> <!– ```julia-repl –> <!– julia>] –> <!–   pkg> add PerfTest –>","category":"page"},{"location":"examples/#Examples","page":"...","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"...","title":"...","text":"Pages = [\"examples/basic.md\"]","category":"page"},{"location":"examples/","page":"...","title":"...","text":"Pages = [\"examples/roofline.md\"]","category":"page"},{"location":"macros/#PerfTest-macros-quick-reference","page":"Macros","title":"PerfTest macros quick reference","text":"","category":"section"},{"location":"macros/","page":"Macros","title":"Macros","text":"The following are the main macros used to define performance test suites. These shall be always used inside a testset (see the [Test] package). Combining the different macros listed in this section gives the full extent of the package features.","category":"page"},{"location":"macros/#Declaring-test-targets","page":"Macros","title":"Declaring test targets","text":"","category":"section"},{"location":"macros/#PerfTest.@perftest","page":"Macros","title":"PerfTest.@perftest","text":"This macro is used to signal that the wrapped expression is a performance test target, and therefore its performance will be sampled and then evaluated following the current suite configuration.\n\nIf the macro is evaluated it does not modify the target at all. The effects of the macro only show when the script is transformed into a performance testing suite.\n\nThis macro is sensitive to context since other adjacent macros can change how the target will be evaluated.\n\nUse the parameter \"samples\" to specify the amount of samples (executions) to take.\n\nArguments\n\nThe target expression\nNumber of samples (default: 10000)\n\nExample\n\n@perftest 2 + 3\n@perftest samples=100 2 + 3\n\n\n\n\n\n","category":"macro"},{"location":"macros/#Declaring-metrics","page":"Macros","title":"Declaring metrics","text":"","category":"section"},{"location":"macros/#PerfTest.@define_metric","page":"Macros","title":"PerfTest.@define_metric","text":"This macro is used to define a new custom metric.\n\nArguments\n\nname : the name of the metric for identification purposes.\nunits : the unit space that the metric values will be in.\nformula block : an expression that returns a single value, which would be the metric value. The formula can have any julia expression inside and additionally some special symbols are supported. The formula may be evaluated several times, so its applied to every target in every test set or just once, if the formula is defined inside a test set, which makes it only applicable to it. NOTE: If there is the need of referring to a variable on a formula block, it first needs to be exported using the macro @export_vars, otherwise an error will occur.\n\nSpecial symbols:\n\n:median_time : will be substituted by the median time the target took to execute in the benchmark.\n:minimum_time: will be substituted by the minimum time the target took to execute in the benchmark.\n:ret_value : will be substituted by the return value of the target.\n:autoflop: will be substituted by the FLOP count the target.\n:printed_output : will be substituted by the standard output stream of the target.\n:iterator : will be substituted by the current iterator value in a loop test set.\n\n\n\n\n\n","category":"macro"},{"location":"macros/#PerfTest.@auxiliary_metric","page":"Macros","title":"PerfTest.@auxiliary_metric","text":"Defines a custom metric for informational purposes that will not be used for testing but will be printed as output.\n\nArguments\n\nname : the name of the metric for identification purposes.\nunits : the unit space that the metric values will be in.\nformula block : an expression that returns a single value, which would be the metric value. The formula can have any julia expression inside and additionally some special symbols are supported. The formula may be evaluated several times, so its applied to every target in every test set or just once, if the formula is defined inside a test set, which makes it only applicable to it.\n\nSpecial symbols:\n\n:median_time : will be substituted by the median time the target took to execute in the benchmark.\n:minimum_time: will be substituted by the minimum time the target took to execute in the benchmark.\n:ret_value : will be substituted by the return value of the target.\n:autoflop: will be substituted by the FLOP count the target.\n:printed_output : will be substituted by the standard output stream of the target.\n:iterator : will be substituted by the current iterator value in a loop test set.\n\n\n\n\n\n","category":"macro"},{"location":"macros/#Declaring-methodologies","page":"Macros","title":"Declaring methodologies","text":"","category":"section"},{"location":"macros/#PerfTest.@perfcompare","page":"Macros","title":"PerfTest.@perfcompare","text":"\n\n\n\n","category":"macro"},{"location":"macros/#PerfTest.@define_eff_memory_throughput","page":"Macros","title":"PerfTest.@define_eff_memory_throughput","text":"This macro is used to define the memory bandwidth of a target in order to execute the effective memory thorughput methodology.\n\nArguments\n\nformula block : an expression that returns a single value, which would be the metric value. The formula can have any julia expression inside and additionally some special symbols are supported. The formula may be evaluated several times, so its applied to every target in every test set or just once, if the formula is defined inside a test set, which makes it only applicable to it.\nratio : the allowed minimum percentage over the maximum attainable that is allowed to pass the test\n\nSpecial symbols:\n\n:median_time : will be substituted by the median time the target took to execute in the benchmark.\n:minimum_time: will be substituted by the minimum time the target took to execute in the benchmark.\n:ret_value : will be substituted by the return value of the target.\n:autoflop: will be substituted by the FLOP count the target.\n:printed_output : will be substituted by the standard output stream of the target.\n:iterator : will be substituted by the current iterator value in a loop test set.\n\nExample:\n\nThe following definition assumes that each execution of the target expression involves transacting 1000 bytes. Therefore the bandwith is 1000 / execution time.\n\n@define_eff_memory_throughput begin\n      1000 / :median_time\nend\n\n\n\n\n\n","category":"macro"},{"location":"macros/#PerfTest.@roofline","page":"Macros","title":"PerfTest.@roofline","text":"This macro enables roofline modelling, if put just before a target declaration (@perftest) it will proceed to evaluate it using a roofline model.\n\nMandatory arguments\n\nformula block: the macro has to wrap a block that holds a formula to obtain the operational intensity of target algorithms.\n\nOptional arguments\n\ncpu_peak : a manual input value for the maximum attainable FLOPS, this will override the empirical runtime benchmark\nmembw_peak : a manual input value for the maximum memory bandwith, this will override the empirical runtime benchmark\ntarget_opint : a desired operational intensity for the target, this will turn operational intensity into a test metric\nactual_flops: another formula that defines the actual performance of the test.\ntarget_ratio : the acceptable ratio between the actual performance and the projected performance from the roofline, this will turn actual performance into a test metric.\n\nSpecial symbols:\n\n:median_time : will be substituted by the median time the target took to execute in the benchmark.\n:minimum_time: will be substituted by the minimum time the target took to execute in the benchmark.\n:ret_value : will be substituted by the return value of the target.\n:autoflop: will be substituted by the FLOP count the target.\n:printed_output : will be substituted by the standard output stream of the target.\n:iterator : will be substituted by the current iterator value in a loop test set.\n\nAny formula block specified in this macro supports these symbols.\n\nExample\n\n@roofline actual_flops=:autoflop target_ratio=0.05 begin\n    mem = ((:iterator + 1) * :iterator)\n    :autoflop / mem\nend\n\nThe code block defines operational intensity, whilst the other arguments define how to measure and compare the actual performance with the roofline performance. If the actual to projected performance ratio goes below the target, the test fails.\n\n\n\n\n\n","category":"macro"},{"location":"macros/#Structure-and-configuration","page":"Macros","title":"Structure and configuration","text":"","category":"section"},{"location":"macros/#PerfTest.@perftest_config","page":"Macros","title":"PerfTest.@perftest_config","text":"Captures a set of configuration parameters that will override the default configuration. The parameters shall be written in TOML syntax, like a subset of the complete configuration (see config.toml generated by executing transform, or transform/configuration.jl for more information). Order is irrelevant. This macro shall be put as high as possible in the test file (code that is above will be transformed using the default configuration).\n\nRecursive transformation:\n\nThis macro will set the new configuration keys for the current file and any other included files. If the included files have the macro as well, those macros will override the configuration locally for each file.\n\nArguments\n\nA String, with the TOML declaration of configuration keys\n\nExample\n\n@perftestconfig \" [roofline]   enabled = false [general]   maxsaved_results = 1   recursive = false \"\n\n\n\n\n\n","category":"macro"},{"location":"macros/#PerfTest.@on_perftest_exec","page":"Macros","title":"PerfTest.@on_perftest_exec","text":"The expression given to this macro will only be executed in the generated suite, and will be deleted if the source code is executed as is.\n\n\n\n\n\n","category":"macro"},{"location":"macros/#PerfTest.@on_perftest_ignore","page":"Macros","title":"PerfTest.@on_perftest_ignore","text":"The expression given to this macro will only be executed in the source code, and will be deleted in the generated performance test suite.\n\n\n\n\n\n","category":"macro"},{"location":"macros/#PerfTest.@export_vars","page":"Macros","title":"PerfTest.@export_vars","text":"@export_vars vars...\n\nExports the specified symbols –along with the values they hold at the moment of the calling– to the scope of metric definitions. In order to use any variable on the definition of a metric such variable needs to be exported with this macro.\n\n\n\n\n\n","category":"macro"},{"location":"examples/memcopyCellArray3D_ParallelStencil/#Roofline-example:-option-pricing","page":"Roofline example: option pricing","title":"Roofline example: option pricing","text":"","category":"section"},{"location":"examples/memcopyCellArray3D_ParallelStencil/","page":"Roofline example: option pricing","title":"Roofline example: option pricing","text":"In this example we setup a roofline model methodology to test the resolution of a binomial tree using a slow implementation.","category":"page"},{"location":"examples/memcopyCellArray3D_ParallelStencil/","page":"Roofline example: option pricing","title":"Roofline example: option pricing","text":"rfd_rt(r,t_per_p) = rfd(t) = exp(-r * t * t_per_p)\nup_st(sigma, t_per_p) = exp(sigma * sqrt(t_per_p))\n\nstruct _Parameters\n    sigma   :: Float64\n    periods :: Int\n    t_per_p :: Float64\n    rfd     :: Function\n    up      :: Float64\n    K       :: Float64\n    S0      :: Float64\n    p       :: Float64\nend\n\nfunction setupProblem(sigma, t, periods_per_t, risk_free_rate, strike, price, p) :: _Parameters\n    return _Parameters(\n        sigma,\n        t * periods_per_t,\n        1 / periods_per_t,\n        rfd_rt(risk_free_rate, 1 / periods_per_t),\n        up_st(sigma, 1 / periods_per_t),\n        strike,\n        price,\n        p\n    )\nend\n\nfunction createBinomialTree(p :: _Parameters)::Tuple{Matrix,Array}\n\n    nodes = (p.periods + 1) * p.periods ÷ 2\n    # A and b\n    Tree = zeros(Float64, nodes, nodes)\n    B = zeros(Float64, nodes)\n\n    # Fill the body of the tree with the discounted expectations\n    for period in 1:(p.periods-1)\n        _nodes = ((period-1)*period÷2+1):((period+1)*(period+0)÷2)\n        for node in _nodes\n            Tree[node, node] = -1\n            Tree[node, node+period] = p.p * p.rfd(p.periods - period)\n            Tree[node, node+period+1] = 1 - p.p * p.rfd(p.periods - period)\n        end\n    end\n\n    # Fill the last level of the tree with the prices at maturity\n    xa = ((p.periods - 1) * p.periods ÷ 2 + 1)\n    xb = ((p.periods + 1) * (p.periods + 0) ÷ 2)\n    down = 1 / p.up\n\n    for node in xa:xb\n        Tree[node, node] = 1\n        B[node] = max((p.S0 * p.up^(xb - node) * down^(node - xa)) - p.K, 0.0)\n    end\n    return Tree, B\nend\n\n\nfunction solveTree(A::Matrix, b::Array, periods::Int)::Array\n\n    nodes = (periods + 1) * periods ÷ 2\n    X = zeros(Float64, nodes)\n    # Last level nodes from a to b\n    xa = ((periods - 1) * periods ÷ 2 + 1)\n    xb = ((periods + 1) * (periods + 0) ÷ 2)\n    for node in xa:xb\n        X[node] = b[node]\n    end\n    # Tree core nodes\n    for period in (periods-1):-1:1\n        _nodes = ((period-1)*period÷2+1):((period+1)*(period+0)÷2)\n        for node in _nodes\n            X[node] = A[node, node+period] * b[node+period] + A[node, node+period+1] * b[node+period+1]\n            b[node] = X[node]\n        end\n    end\n\n    return X\nend\n\noption_price(solution :: Array) = solution[1]\n","category":"page"},{"location":"examples/memcopyCellArray3D_ParallelStencil/","page":"Roofline example: option pricing","title":"Roofline example: option pricing","text":"The following is the recipe file that sets up the performance test suite:","category":"page"},{"location":"examples/memcopyCellArray3D_ParallelStencil/","page":"Roofline example: option pricing","title":"Roofline example: option pricing","text":"using Test\nusing PerfTest\n\ninclude(\"main3.jl\")\n\n# CONFIG\n@perftest_config begin\n    regression.enabled = false\n    roofline.autoflops = true\n    roofline.tolerance.min_percentage = 1.0\nend\n\n\n@testset \"Performance Tests\" begin\n\n    @testset \"Tree construction\" begin\n\n        @testset \"Periods\" for n_periods in [16, 64, 128]\n\n            param = setupProblem(0.04, 1, n_periods, 0.04, 100, 100, 0.5)\n\n            @roofline actual_flops=:autoflop target_ratio=0.05 begin\n                mem = ((:iterator + 1) * :iterator)\n                :autoflop / mem\n            end\n            A, b = createBinomialTree(param)\n\n\n            @perftest solveTree(A, b, param.periods)\n        end\n    end\nend","category":"page"},{"location":"examples/memcopyCellArray3D_ParallelStencil/","page":"Roofline example: option pricing","title":"Roofline example: option pricing","text":"The recipe file specifies the following:","category":"page"},{"location":"examples/memcopyCellArray3D_ParallelStencil/","page":"Roofline example: option pricing","title":"Roofline example: option pricing","text":"The target will be evaluated using a roofline model\nThe basic regression methodology is disabled\nThe tolerance below the threshold will be zero\nThe autoflops feature is enabled\nThe roofline macro additionally receives how to calculate the flop count (actual_lops=:autoflop) and the threshold of the actual performance vs model performance is 5%","category":"page"},{"location":"examples/mock2-memorythroughput/#Effective-memory-throughput","page":"Effective memory throughput","title":"Effective memory throughput","text":"","category":"section"},{"location":"examples/mock2-memorythroughput/","page":"Effective memory throughput","title":"Effective memory throughput","text":"This mock example explains how to setup the effective memory throughput methodology.","category":"page"},{"location":"examples/mock2-memorythroughput/","page":"Effective memory throughput","title":"Effective memory throughput","text":"The memory bandwidth test is more appropriate for functions that are primarily moving data, with reduced protagonism to computation performance.","category":"page"},{"location":"examples/mock2-memorythroughput/","page":"Effective memory throughput","title":"Effective memory throughput","text":"\nusing Test\nusing PerfTest\n\n\n@perftest_config \"\n[regression]\nenabled = false\n\"\n\n\n# TEST TARGET\nfunction copyvec_squared(a :: Vector{Int})\n\n    b = zeros(length(a))\n\n    for i in 1:length(a)\n        b[i] = a[i] * a[i]\n    end\n\n    return b\nend\n\n@testset \"Example\" begin\n\n    N = 1000000\n\n    a = rand(Int, N)\n\n    # To use a variable in macro formulas, it has to be exported (i.e. N)\n    @export_vars N\n    # The ratio sets the threshold, being 1.0 the maximum empirical bandwidth and 0.6 = 60% of such maximum\n    @define_eff_memory_throughput ratio=0.6 begin\n        # The main block of the macro holds the formula for the bandwidth (therefore BYTES divided by SECONDS) on\n        # one single execution of the test target.\n        # In this case per execution N elements of 4 Bytes are Read on Memort + Written\n        # on Cache + Written on Memory (Copy on write assumption by default)\n        # The median time is considered an adequate measure for the denominator in this case\n        # THUS:\n        N * 4 * 3 / :median_time\n    end\n\n    # Set the target\n    b = @perftest copyvec_squared(a)\nend","category":"page"},{"location":"examples/mock2-memorythroughput/","page":"Effective memory throughput","title":"Effective memory throughput","text":"This test results in a failure to meet the expectation.","category":"page"},{"location":"#[PerfTest.jl](https://github.com/JuliaPerf/PerfTest.jl)-[![Star-on-GitHub](https://img.shields.io/github/stars/JuliaPerf/PerfTest.jl.svg)](https://github.com/JuliaPerf/PerfTest.jl/stargazers)","page":"Introduction","title":"PerfTest.jl (Image: Star on GitHub)","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The package PerfTest provides the user with a performance regression unit testing framework. This framework consists of a collection of macros used to declaratively define a performance test suite. Scripts with said macros can then be transformed into performance suites using the transform method. This package is focused on providing an easy and fast way to develop performance suites, with additional features to customise them following the demands of the use case.","category":"page"},{"location":"#Dependencies","page":"Introduction","title":"Dependencies","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"PerfTest relies on:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"[MacroTools]\n[JLD2]\n[MPI]\n[STREAMBenchmark]\n[GFlops]\n[UnicodePlots]\n[Test]\n[Suppressor]","category":"page"},{"location":"#Contributors","page":"Introduction","title":"Contributors","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This project has been developed as a Master's thesis by Daniel Sergio Vega Rodriguez. Thus, the contributors to this project have been so far:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Daniel Sergio Vega Rodriguez (@Dvegrod), Università della Svizzera italiana (USI): developer\nDr. Samuel Omlin (@omlins), Swiss National Supercomputing Centre (CSCS), ETH Zurich: original idea and Master's thesis supervisor\nProf. Olaf Schenk, Università della Svizzera italiana (USI): Master's thesis supervisor\nDr. Pasadakis Dimosthenis, Università della Svizzera italiana (USI): additional advisor","category":"page"}]
}
